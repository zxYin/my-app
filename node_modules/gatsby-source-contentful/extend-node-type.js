"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Promise = require(`bluebird`);

var _require = require(`graphql`),
    GraphQLObjectType = _require.GraphQLObjectType,
    GraphQLBoolean = _require.GraphQLBoolean,
    GraphQLString = _require.GraphQLString,
    GraphQLInt = _require.GraphQLInt,
    GraphQLFloat = _require.GraphQLFloat;

var qs = require(`qs`);
var base64Img = require(`base64-img`);
var _ = require(`lodash`);
var path = require(`path`);

var cacheImage = require(`./cache-image`);

var _require2 = require(`./schemes`),
    ImageFormatType = _require2.ImageFormatType,
    ImageResizingBehavior = _require2.ImageResizingBehavior,
    ImageCropFocusType = _require2.ImageCropFocusType;

var isImage = function isImage(image) {
  return _.includes([`image/jpeg`, `image/jpg`, `image/png`, `image/webp`, `image/gif`], _.get(image, `file.contentType`));
};

var getBase64Image = function getBase64Image(imageProps) {
  if (!imageProps) return null;

  var requestUrl = `https:${imageProps.baseUrl}?w=20`;
  // TODO add caching.
  return new Promise(function (resolve) {
    base64Img.requestBase64(requestUrl, function (a, b, body) {
      resolve(body);
    });
  });
};

var getBasicImageProps = function getBasicImageProps(image, args) {
  var aspectRatio = void 0;
  if (args.width && args.height) {
    aspectRatio = args.width / args.height;
  } else {
    aspectRatio = image.file.details.image.width / image.file.details.image.height;
  }

  return {
    baseUrl: image.file.url,
    contentType: image.file.contentType,
    aspectRatio,
    width: image.file.details.image.width,
    height: image.file.details.image.height
  };
};

var createUrl = function createUrl(imgUrl) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // Convert to Contentful names and filter out undefined/null values.
  var args = _.pickBy({
    w: options.width,
    h: options.height,
    fl: options.jpegProgressive ? `progressive` : null,
    q: options.quality,
    fm: options.toFormat || ``,
    fit: options.resizingBehavior || ``,
    f: options.cropFocus || ``,
    bg: options.background || ``
  }, _.identity);
  return `${imgUrl}?${qs.stringify(args)}`;
};
exports.createUrl = createUrl;

var resolveResponsiveResolution = function resolveResponsiveResolution(image, options) {
  if (!isImage(image)) return null;

  var _getBasicImageProps = getBasicImageProps(image, options),
      baseUrl = _getBasicImageProps.baseUrl,
      width = _getBasicImageProps.width,
      aspectRatio = _getBasicImageProps.aspectRatio;

  var desiredAspectRatio = aspectRatio;

  // If we're cropping, calculate the specified aspect ratio.
  if (options.height) {
    desiredAspectRatio = options.width / options.height;
  }

  // If the user selected a height (so cropping) and fit option
  // is not set, we'll set our defaults
  if (options.height) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  }

  // Create sizes (in width) for the image. If the width of the
  // image is 800px, the sizes would then be: 800, 1200, 1600,
  // 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution
  var sizes = [];
  sizes.push(options.width);
  sizes.push(options.width * 1.5);
  sizes.push(options.width * 2);
  sizes.push(options.width * 3);
  sizes = sizes.map(Math.round);

  // Filter out sizes larger than the image's width.
  var filteredSizes = sizes.filter(function (size) {
    return size < width;
  });

  // Sort sizes for prettiness.
  var sortedSizes = _.sortBy(filteredSizes);

  // Create the srcSet.
  var srcSet = sortedSizes.map(function (size, i) {
    var resolution = void 0;
    switch (i) {
      case 0:
        resolution = `1x`;
        break;
      case 1:
        resolution = `1.5x`;
        break;
      case 2:
        resolution = `2x`;
        break;
      case 3:
        resolution = `3x`;
        break;
      default:
    }
    var h = Math.round(size / desiredAspectRatio);
    return `${createUrl(baseUrl, (0, _extends3.default)({}, options, {
      width: size,
      height: h
    }))} ${resolution}`;
  }).join(`,\n`);

  var pickedHeight = void 0;
  if (options.height) {
    pickedHeight = options.height;
  } else {
    pickedHeight = options.width / desiredAspectRatio;
  }

  return {
    aspectRatio: desiredAspectRatio,
    baseUrl,
    width: Math.round(options.width),
    height: Math.round(pickedHeight),
    src: createUrl(baseUrl, (0, _extends3.default)({}, options, {
      width: options.width
    })),
    srcSet
  };
};
exports.resolveResponsiveResolution = resolveResponsiveResolution;

var resolveResponsiveSizes = function resolveResponsiveSizes(image, options) {
  if (!isImage(image)) return null;

  var _getBasicImageProps2 = getBasicImageProps(image, options),
      baseUrl = _getBasicImageProps2.baseUrl,
      width = _getBasicImageProps2.width,
      aspectRatio = _getBasicImageProps2.aspectRatio;

  var desiredAspectRatio = aspectRatio;

  // If we're cropping, calculate the specified aspect ratio.
  if (options.maxHeight) {
    desiredAspectRatio = options.maxWidth / options.maxHeight;
  }

  // If the users didn't set a default sizes, we'll make one.
  if (!options.sizes) {
    options.sizes = `(max-width: ${options.maxWidth}px) 100vw, ${options.maxWidth}px`;
  }

  // Create sizes (in width) for the image. If the max width of the container
  // for the rendered markdown file is 800px, the sizes would then be: 200,
  // 400, 800, 1200, 1600, 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution
  var sizes = [];
  sizes.push(options.maxWidth / 4);
  sizes.push(options.maxWidth / 2);
  sizes.push(options.maxWidth);
  sizes.push(options.maxWidth * 1.5);
  sizes.push(options.maxWidth * 2);
  sizes.push(options.maxWidth * 3);
  sizes = sizes.map(Math.round);

  // Filter out sizes larger than the image's maxWidth.
  var filteredSizes = sizes.filter(function (size) {
    return size < width;
  });

  // Add the original image to ensure the largest image possible
  // is available for small images.
  filteredSizes.push(width);

  // Sort sizes for prettiness.
  var sortedSizes = _.sortBy(filteredSizes);

  // Create the srcSet.
  var srcSet = sortedSizes.map(function (width) {
    var h = Math.round(width / desiredAspectRatio);
    return `${createUrl(image.file.url, (0, _extends3.default)({}, options, {
      width,
      height: h
    }))} ${Math.round(width)}w`;
  }).join(`,\n`);

  return {
    aspectRatio: desiredAspectRatio,
    baseUrl,
    src: createUrl(baseUrl, (0, _extends3.default)({}, options, {
      width: options.maxWidth,
      height: options.maxHeight
    })),
    srcSet,
    sizes: options.sizes
  };
};
exports.resolveResponsiveSizes = resolveResponsiveSizes;

var resolveResize = function resolveResize(image, options) {
  if (!isImage(image)) return null;

  var _getBasicImageProps3 = getBasicImageProps(image, options),
      baseUrl = _getBasicImageProps3.baseUrl,
      aspectRatio = _getBasicImageProps3.aspectRatio;

  // If the user selected a height (so cropping) and fit option
  // is not set, we'll set our defaults


  if (options.height) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  }

  var pickedWidth = options.width;
  var pickedHeight = void 0;
  if (options.height) {
    pickedHeight = options.height;
  } else {
    pickedHeight = pickedWidth / aspectRatio;
  }
  return {
    src: createUrl(image.file.url, options),
    width: Math.round(pickedWidth),
    height: Math.round(pickedHeight),
    aspectRatio,
    baseUrl
  };
};

exports.resolveResize = resolveResize;

exports.extendNodeType = function (_ref) {
  var type = _ref.type,
      store = _ref.store;

  if (type.name !== `ContentfulAsset`) {
    return {};
  }

  var getTracedSVG = function () {
    var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(args) {
      var _require3, traceSVG, image, options, contentType, absolutePath, extension;

      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _require3 = require(`gatsby-plugin-sharp`), traceSVG = _require3.traceSVG;
              image = args.image, options = args.options;
              contentType = image.file.contentType;

              if (!(contentType.indexOf(`image/`) !== 0)) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return", null);

            case 5:
              _context.next = 7;
              return cacheImage(store, image, options);

            case 7:
              absolutePath = _context.sent;
              extension = path.extname(absolutePath);
              return _context.abrupt("return", traceSVG({
                file: {
                  internal: image.internal,
                  name: image.file.fileName,
                  extension,
                  absolutePath
                },
                args: { toFormat: `` },
                fileArgs: options
              }));

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, undefined);
    }));

    return function getTracedSVG(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    resolutions: {
      type: new GraphQLObjectType({
        name: `ContentfulResolutions`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          tracedSVG: {
            type: GraphQLString,
            resolve: getTracedSVG
          },
          aspectRatio: { type: GraphQLFloat },
          width: { type: GraphQLFloat },
          height: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString },
          srcWebp: {
            type: GraphQLString,
            resolve(_ref3) {
              var image = _ref3.image,
                  options = _ref3.options,
                  context = _ref3.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var resolutions = resolveResponsiveResolution(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(resolutions, `src`);
            }
          },
          srcSetWebp: {
            type: GraphQLString,
            resolve(_ref4) {
              var image = _ref4.image,
                  options = _ref4.options,
                  context = _ref4.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var resolutions = resolveResponsiveResolution(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(resolutions, `srcSet`);
            }
          }
        }
      }),
      args: {
        width: {
          type: GraphQLInt,
          defaultValue: 400
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        background: {
          type: GraphQLString,
          defaultValue: null
        }
      },
      resolve: function resolve(image, options, context) {
        return Promise.resolve(resolveResponsiveResolution(image, options)).then(function (node) {
          return (0, _extends3.default)({}, node, {
            image,
            options,
            context
          });
        });
      }
    },
    sizes: {
      type: new GraphQLObjectType({
        name: `ContentfulSizes`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          tracedSVG: {
            type: GraphQLString,
            resolve: getTracedSVG
          },
          aspectRatio: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString },
          srcWebp: {
            type: GraphQLString,
            resolve(_ref5) {
              var image = _ref5.image,
                  options = _ref5.options,
                  context = _ref5.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var sizes = resolveResponsiveSizes(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(sizes, `src`);
            }
          },
          srcSetWebp: {
            type: GraphQLString,
            resolve(_ref6) {
              var image = _ref6.image,
                  options = _ref6.options,
                  context = _ref6.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var sizes = resolveResponsiveSizes(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(sizes, `srcSet`);
            }
          },
          sizes: { type: GraphQLString }
        }
      }),
      args: {
        maxWidth: {
          type: GraphQLInt,
          defaultValue: 800
        },
        maxHeight: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        background: {
          type: GraphQLString,
          defaultValue: null
        },
        sizes: {
          type: GraphQLString
        }
      },
      resolve: function resolve(image, options, context) {
        return Promise.resolve(resolveResponsiveSizes(image, options)).then(function (node) {
          return (0, _extends3.default)({}, node, {
            image,
            options,
            context
          });
        });
      }
    },
    responsiveResolution: {
      deprecationReason: `We dropped the "responsive" part of the name to make it shorter https://github.com/gatsbyjs/gatsby/pull/2320/`,
      type: new GraphQLObjectType({
        name: `ContentfulResponsiveResolution`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          tracedSVG: {
            type: GraphQLString,
            resolve: getTracedSVG
          },
          aspectRatio: { type: GraphQLFloat },
          width: { type: GraphQLFloat },
          height: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString }
        }
      }),
      args: {
        width: {
          type: GraphQLInt,
          defaultValue: 400
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        background: {
          type: GraphQLString,
          defaultValue: null
        }
      },
      resolve(image, options, context) {
        return resolveResponsiveResolution(image, options);
      }
    },
    responsiveSizes: {
      deprecationReason: `We dropped the "responsive" part of the name to make it shorter https://github.com/gatsbyjs/gatsby/pull/2320/`,
      type: new GraphQLObjectType({
        name: `ContentfulResponsiveSizes`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          tracedSVG: {
            type: GraphQLString,
            resolve: getTracedSVG
          },
          aspectRatio: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString },
          sizes: { type: GraphQLString }
        }
      }),
      args: {
        maxWidth: {
          type: GraphQLInt,
          defaultValue: 800
        },
        maxHeight: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        sizes: {
          type: GraphQLString
        },
        background: {
          type: GraphQLString,
          defaultValue: null
        }
      },
      resolve(image, options, context) {
        return resolveResponsiveSizes(image, options);
      }
    },
    resize: {
      type: new GraphQLObjectType({
        name: `ContentfulResize`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          tracedSVG: {
            type: GraphQLString,
            resolve: getTracedSVG
          },
          src: { type: GraphQLString },
          width: { type: GraphQLInt },
          height: { type: GraphQLInt },
          aspectRatio: { type: GraphQLFloat }
        }
      }),
      args: {
        width: {
          type: GraphQLInt,
          defaultValue: 400
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        jpegProgressive: {
          type: GraphQLBoolean,
          defaultValue: true
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        background: {
          type: GraphQLString,
          defaultValue: null
        }
      },
      resolve(image, options, context) {
        return resolveResize(image, options);
      }
    }
  };
};